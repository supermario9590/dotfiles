#+title: XMonad Config
#+property: header-args :tangle ./xmonad.hs

* About this config

XMonad is a dynamically tiling window manager which is written and configured in Haskell.

- XMonad Website: [[https://xmonad.org]]

* Imports

These are haskell modules that we will call upon later in the config.

** Base

#+begin_src haskell
import XMonad
import qualified XMonad.StackSet as W
import System.Exit
#+end_src

** Utilities

#+begin_src haskell
import XMonad.Util.EZConfig
import XMonad.Util.Run
import XMonad.Util.SpawnOnce
#+end_src

** Hooks

#+begin_src haskell
import XMonad.Hooks.ManageDocks
import XMonad.Hooks.EwmhDesktops
import XMonad.Hooks.DynamicLog
#+end_src
** Data

#+begin_src haskell
import Data.Monoid
import qualified Data.Map as M
#+end_src

* Variables

These are variables that will be useful throughout the config.

#+begin_src haskell
myTerminal :: String
myTerminal = "st"

myFocusFollowsMouse :: Bool
myFocusFollowsMouse = True

myClickJustFocuses :: Bool
myClickJustFocuses = False

myBorderWidth :: Dimension
myBorderWidth = 0

myModMask :: KeyMask
myModMask = mod4Mask

myNormalBorderColor :: String
myNormalBorderColor  = "#dddddd"

myFocusedBorderColor :: String
myFocusedBorderColor = "#ff0000"

myEditor :: String
myEditor = "emacs"

myFont :: String
myFont = "xft:Mononoki Nerd Font:bold:size=9:antialias=true:hinting=true"

myBrowser :: String
myBrowser = "chromium"
#+end_src

* Autostart

This configures what commands are run on startup.

#+begin_src haskell
myStartupHook = do
  spawnOnce "nitrogen --restore &"
  spawnOnce "picom -f &"
  spawnOnce "xfce4-power-manager &"
#+end_src

* Layouts

XMonad has lots of layouts that can be imported manually. I personally do not use that.

#+begin_src haskell
myLayout = avoidStruts (tiled ||| Mirror tiled ||| Full)
  where
    -- default tiling algorithm partitions the screen into two panes
    tiled   = Tall nmaster delta ratio

    -- The default number of windows in the master pane
    nmaster = 1

    -- Default proportion of screen occupied by master pane
    ratio   = 1/2

    -- Percent of screen to increment by when resizing panes
    delta   = 3/100
#+end_src

* Workspaces

XMonad has these things called workspaces.

#+begin_src haskell
xmobarEscape :: String -> String
xmobarEscape = concatMap doubleLts
  where doubleLts '<' = "<<"
        doubleLts x    = [x]

myWorkspaces :: [ String ]
myWorkspaces = clickable . (map xmobarEscape)
  $ [ "1", "2", "3" ,"4" ,"5" ,"6" ,"7" ,"8" ,"9" ]
  where
    clickable l = [ "<action=xdotool key super+" ++ show (n) ++ "> " ++ ws ++ " </action>" |
                  (i,ws) <- zip [1..9] l,
                  let n = i ]
#+end_src

* Manage Hook

Sets some rules for certain programs. Examples include forcing certain programs to always float, or to always appear on a certain workspace.  Forcing programs to a certain workspace with a doShift requires xdotool if you are using clickable workspaces. You need the className or title of the program. Use xprop to get this info.

#+begin_src haskell
myManageHook :: XMonad.Query (Data.Monoid.Endo WindowSet)
myManageHook = composeAll
  [ className =? "MPlayer"        --> doFloat
  , className =? "Gimp"           --> doFloat
  , resource  =? "desktop_window" --> doIgnore
  , resource  =? "kdesktop"       --> doIgnore ]
#+end_src

* Log Hook

Sets opacity for inactive (unfocused) windows.

#+begin_src haskell
myLogHook :: X ()
myLogHook = return ()
#+end_src

* Event Hook

This manages what happens when something else hapens.

#+begin_src haskell
myEventHook :: Event -> X All
myEventHook = mempty
#+end_src
* Keybindings

I am using XMonad.Util.EZConfig to set keybindings.

|-----------------------------+--------------------------------------------|
| A few important keybindings | Associated action                          |
|-----------------------------+--------------------------------------------|
| MODKEY + SHIFT + RETURN     | Opens terminal (ST)                        |
| MODKEY + P                  | Runs Dmenu                                 |
| MODKEY + SHIFT + C          | Closes focused window                      |
| MODKEY + 1 - 9              | Switches workspaces                        |
| MODKEY + SHIFT + 1 - 9      | Moves focused window to selected workspace |
|-----------------------------+--------------------------------------------|

#+begin_src haskell
myKeys :: [ ( String, X () ) ]
myKeys =

  -- launch a terminal
  [ ("M-S-<Return>", spawn myTerminal)

  -- launch dmenu
  , ("M-p", spawn "dmenu_run")

  -- launch gmrun
  , ("M-S-p", spawn "gmrun")

  -- close focused window
  , ("M-S-c", kill)

  -- Rotate through the available layout algorithms
  , ("M-<Space>", sendMessage NextLayout)

  -- Resize viewed windows to the correct size
  , ("M-n", refresh)

  -- Move focus to the next window
  , ("M-<Tab>", windows W.focusDown)

  -- Move focus to the next window
  , ("M-j", windows W.focusDown)

  -- Move focus to the previous window
  , ("M-k", windows W.focusUp  )

  -- Move focus to the master window
  , ("M-m", windows W.focusMaster  )

  -- Swap the focused window and the master window
  , ("M-<Return>", windows W.swapMaster)

  -- Swap the focused window with the next window
  , ("M-S-j", windows W.swapDown  )

  -- Swap the focused window with the previous window
  , ("M-S-k", windows W.swapUp    )

  -- Shrink the master area
  , ("M-h", sendMessage Shrink)

  -- Expand the master area
  , ("M-l", sendMessage Expand)

  -- Push window back into tiling
  , ("M-t", withFocused $ windows . W.sink)

  -- Increment the number of windows in the master area
  , ("M-,", sendMessage (IncMasterN 1))

  -- Deincrement the number of windows in the master area
  , ("M-.", sendMessage (IncMasterN (-1)))

  -- Toggle the status bar gap
  -- Use this binding with avoidStruts from Hooks.ManageDocks.
  -- See also the statusBar function from Hooks.DynamicLog.
  --
  -- , ("M-b", sendMessage ToggleStruts)

  -- Quit xmonad
  , ("M-S-q", io (exitWith ExitSuccess))

  -- Restart xmonad
  , ("M-S-r", spawn "xmonad --recompile; xmonad --restart")

  -- Emacs
  , ("C-e e", spawn "emacs")
  , ("C-e d", spawn "emacs --eval '(dired nil)'")

  -- Media keys
  , ("<XF86AudioLowerVolume>", spawn "amixer set Master 5%-")
  , ("<XF86AudioRaiseVolume>", spawn "amixer set Master 5%+")
  , ("<XF86AudioMute>", spawn "amixer set Master toggle")
  ]
#+end_src

* Main

This is what is run whenever XMonad is executed. Everything comes together here.

#+begin_src haskell
main = do
  xmproc <- spawnPipe "xmobar"
  xmonad $ ewmh def {
                    -- simple stuff
                    terminal           = myTerminal,
                    focusFollowsMouse  = myFocusFollowsMouse,
                    clickJustFocuses   = myClickJustFocuses,
                    borderWidth        = myBorderWidth,
                    modMask            = myModMask,
                    workspaces         = myWorkspaces,
                    normalBorderColor  = myNormalBorderColor,
                    focusedBorderColor = myFocusedBorderColor,
                    
                    -- hooks, layouts
                    layoutHook         = myLayout,
                    manageHook         = myManageHook <+> manageDocks,
                    handleEventHook    = myEventHook <+> fullscreenEventHook <+> docksEventHook,
                    logHook            = myLogHook <+> dynamicLogWithPP xmobarPP
                    { ppOutput = hPutStrLn xmproc
                    , ppCurrent = xmobarColor "yellow" "" . wrap "[" "]"
                    , ppHiddenNoWindows = xmobarColor "grey" ""
                    , ppTitle   = xmobarColor "green"  "" . shorten 40
                    , ppVisible = wrap "("")"
                    , ppUrgent  = xmobarColor "red" "yellow"
                    , ppHidden = xmobarColor "grey" "" . wrap "" "*"
                    },
                    startupHook        = myStartupHook
                    } `additionalKeysP` myKeys
#+end_src
